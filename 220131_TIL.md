# 220131_TIL

### Python

#### 비트연산

- 모든 연산을 하기 위해서 십진수를 2진수로 바꾼다음 연산함
- `A (비트 연산자) B`: A를 B만큼 또는 B와 비트 연산을 실시한다는 의미
- 연산 시 자릿수가 모자라면 앞에서부터 0을 붙인 다음 자릿수를 동일하게 만들어서 연산함
  - 예) 8 & 1 => 1000과 0001에 대한 AND 비트 연산 실시 => 0


| 연산자 | 의미                   | 예시                                       |
| :----: | ---------------------- | ------------------------------------------ |
|   >>   | 오른쪽 shift 비트 연산 | A >> B (A를 B만큼 오른쪽 시프트 비트 연산) |
|   <<   | 왼쪽 shift 비트 연산   | A << B (A를 B만큼 왼쪽 시프트 비트 연산)   |
|   &    | 비트 연산 AND          | A & B (A와 B의 AND 비트 연산)              |
|   ^    | 비트 연산 XOR          | A ^ B (A와 B의 XOR 비트 연산)              |
|   \|   | 비트 연산 OR           | A \| B (A와 B의 OR 비트 연산)              |

**<오른쪽 shift 비트 연산>** `>>`

```python
print(1>>3) # 0 # 1을 2진수로 변환하면 1이고, 이를 오른쪽으로 3칸 밀면 0001이 되는 것이 아니라, 수가 사라진다고 보면 됨. 따라서 0이 됨
print(8>>1) # 4 # 8은 이진수로 1000이고, 이를 오른쪽으로 한칸 밀면 0100 → 100이고 이를 십진수로 변환하면 4이다.
```



**<왼쪽 shift 비트 연산>** `<<`

```python
i=8
print(1<<i) # 256 # 1을 왼쪽으로 8칸 밀어라
# 1은 이진수로 바꿔도 1인데 왼쪽으로 8칸 민다는 의미는 0을 뒤에 8번 붙인다고 생각하면 됨
# 100000000이 되고, 이를 십진수로 변환하면 256이다.
print(i<<1) # 16 # 8을 왼쪽으로 1칸 밀어라
# 8을 이진수로 변환하면 1000이고 여기서 왼쪽으로 밀면서 뒤에 0을 한 칸 추가하면 10000이고
# 이를 십진수로 변환하면 16이다.
```



**<AND 비트 연산>** `&`

같은 자리수끼리 연산하여 두 수 모두 1인 경우에만 1이 됨
따라서 연산 결과 모두 불일치한다면, 그 결과는 0임 / 반대로 모두 일치한다면 원래 숫자 반환

```python
print(1 & 1) # 1
print(8 & 9)  # 8
print(1011 & 1111) # 83
print(bin(1011), bin(1111)) #1111110011, 10001010111 #10자리, 11자리
# 비트 연산
# 01111110011
# 10001010111
# 00001010011 → 83
print(bin(83)) # 1010011
```



**<XOR 비트 연산>** `^`

같은 자리수끼리 연산하여 두 비트의 값이 서로 다르면 1이 됨

```python
print(1011 ^ 1111) # 1956
print(bin(1011), bin(1111)) #1111110011, 10001010111 #10자리, 11자리
# 01111110011
# 10001010111
# 11110100100 → 1956
print(bin(1956)) # 11110100100
```



**<OR 비트 연산>** `|`

같은 자리수끼리 연산하여 두 비트의 값 중 하나만 1이어도 1이 됨

```python
print(1011|1111) # 2039
print(bin(1011), bin(1111)) #1111110011, 10001010111 #10자리, 11자리
# 01111110011
# 10001010111
# 11111110111 → 2039
print(bin(2039)) # 11111110111
```

