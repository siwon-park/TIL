# 220316_TIL

## 트리(Tree)

### 1. 정의 및 특징

비선형 구조, 계층형 자료 구조, 한 개 이상의 노드로 이루어진 유한 집합, 원소들 간 `1:N`관계인 자료 구조

상위 원소에서 하위 원소로 내려가면서 확장되는 나무(tree) 모양의 구조

※ 그래프는 N:N관계, 트리는 1:N관계이므로, 그래프가 더 포괄적임. 따라서 트리를 무방향 그래프라고 함

- 트리는 연결 컴포넌트(Conntected Component)다
  - 트리에 속한 임의의 정점 u, v사이에 경로가 반드시 하나만 존재함(사이클이 없기 때문)
- 트리는 사이클(Cycle)이 없다
  - 따라서 트리를 순회할 때 굳이 중복을 방지하기 위해 방문 표시를 하지 않아도 된다.
- 트리는 분리될 수 있으며, 이 분리된 집합 또한 하나의 트리이며, 서브 트리라고 한다.

- 노드가 하나만 있더라도 트리라고 부를 수 있다.
- 트리로 포함관계를 표현할 수 있으며, 괄호를 표현할 수도 있다.



### 2. 구조

- 노드(Node, Vertex) : 트리의 원소, 트리의 노드 수는 간선의 수 +1개이다.
  - 루트 노드: 트리의 시작점이 되는 노드. 조상 노드가 없음
  - 리프 노드, 단말 노드: 트리의 제일 끝단에 있는 노드. 자식 노드가 없음
  - 형제 노드: 같은 부모 노드의 자식 노드들
  - 조상 노드: 한 노드에서 간선을 따라 루트 노드까지 이르는 경로에 있는 노드들
  - 자손 노드: 서브 트리에 있는 하위 노드들
- 간선(Edge) : 노드를 연결하는 선, 트리의 노드가 V개일 때 간선의 수는 V-1개다.
- 차수(Indegree) : 노드에 연결된 자식 노드의 수
  - 트리의 차수 : 트리에 있는 노드의 차수 중에서 가장 큰 값을 말함
- 높이(height) : 루트 노드에서 어떤 한 노드에 이르는 간선 수, 노드의 레벨 또는 계층
  - 트리의 높이 : 트리에 있는 노드의 높이 중에서 가장 큰 값



### 3. 종류

#### 이진 트리(Binary Tree)

모든 노드들이 2개의 서브 트리를 갖는 특별한 트리이며, 각 노드가 최대 2개의 노드를 가질 수 있음

이 때, 이 2개의 노드를 왼쪽 자식 노드, 오른쪽 자식 노드라고 부름

높이가 h인 이진 트리가 가질 수 있는 노드의 최소 개수는 h+1개이며, 최대 개수는 2^(h+1) -1개이다.

이진 트리에서 노드에 번호를 매길 때, 일반적으로 위에서 부터 좌측에서 부터 오름차순으로 매긴다.

- 부모 노드의 번호(P) x2 = 왼쪽 자식 노드 번호(L)
  - L = P*2
  - R = P*2 + 1 또는 R = L + 1
  - P = L//2 또는 R//2



#### 포화 이진 트리(Full Binary Tree)

리프 노드를 제외한 모든 노드가 2개의 자식 노드를 가지는 이진 트리(사실 리프 노드도 2개의 보이지 않는 트리를 갖고 있다고 가정함) => 모든 레벨에 노드가 포화 상태임. 따라서 노드의 개수는 2^(h+1) -1 개



#### 완전 이진 트리(Complete Binary Tree)

포화 이진 트리에서 노드 번호 1번부터 n번까지 빠짐없이 차있되(이전 높이까지의 노드는 모두 차 있되), 마지막 높이에 있는 노드는 다 차있지 않은 이진 트리. 단, 마지막 높이에 있는 노드 또한 왼쪽에서부터 차 있어야 함



#### 편향 이진 트리(Skewed Binary Tree)

높이 h에 대한 최소 개수의 노드를 가지면서 한쪽 방향으로만 자식 노드를 가지는 이진 트리



### 4. 순회(Traversal)

중복없이 체계적으로(빠짐없이), 트리의 각 노드를 방문하는 것. 깊이 우선 탐색(DFS)으로 순회하며, 반드시 오른쪽 자식보다 왼쪽 자식을 먼저 방문한다. 사실 상 트리의 순회는 모든 정점을 3번씩 방문하는 셈이다. (처음 들어오면서 한번, 왼쪽 아래로 나갔다가 다시 들어오면서 1번, 오른쪽 아래로 나갔다가 다시 들어오면서 1번)

트리는 실제로 무방향 그래프이지만, 탐색을 위해 부모에서 자식 방향으로 유향 형태로 저장한다.

V : 루트 노드 / L : 왼쪽 서브 트리 / R : 오른쪽 서브 트리

순회 결과를 카운트해서 루트 노드 수는 1개, 왼쪽 서브 트리의 노드 수는 l개, 오른쪽 서브 트리의 노드 수는 r개이며, 합산하면 1+l+r이고,  재귀적으로 계산하면 모든 노드의 수를 구할 수 있음

```python
def subtree_size(v):
    if v == 0:
        return 0
    l = subtree_size(L[v])
    r = subtree_size(R[v])
    return l+r+1 # 모든 노드의 개수
```



#### 1. 전위 순회(Preorder) - VLR

정점에 처음 진입하면서 방문 기록

- 순회 방법: 
  1. 현재 노드를 방문 처리함
  2. 현재 노드의 왼쪽 서브 트리로 이동함
  3. 현재 노드의 오른쪽 서브 트리로 이동

![image](https://user-images.githubusercontent.com/93081720/158597757-063003da-4a06-42e8-af6f-5989c32bc7a0.png)

**[전위 순회 결과]**

![image](https://user-images.githubusercontent.com/93081720/158604456-076a2915-c5b5-4e6f-88e3-49c4a8dfdf45.png)

```python 
preorder(1) # 1 2 4 8 9 5 10 3 6 7
```



#### 2. 중위 순회(Inorder) - LVR

왼쪽 자식에서 돌아오고 나서 방문 기록

- 순회 방법:
  1. 현재 노드의 왼쪽 서브 트리로 이동함
  2. 현재 노드를 방문 처리함
  3. 현재 노드의 오른쪽 서브 트리로 이동

![image](https://user-images.githubusercontent.com/93081720/158597845-52bab2d0-55c1-4482-985e-b1a1a694ed57.png)

**[중위 순회 결과]**

![image](https://user-images.githubusercontent.com/93081720/158604737-7a17b84e-f197-43ff-95f3-52eed76ceecd.png)

```python
inorder(1) # 8 4 9 2 10 5 1 6 3 7
```



#### 3. 후위 순회(Postorder) - LRV

왼쪽, 오른쪽 자식에서 돌아오고 나서 방문 기록

- 순회 방법:
  1. 현재 노드의 왼쪽 서브 트리로 이동함
  2. 현재 노드의 오른쪽 서브 트리로 이동
  3. 현재 노드를 방문 처리함

![image](https://user-images.githubusercontent.com/93081720/158597951-90774e06-c355-42d0-95e7-65210c144e70.png)

**[후위 순회 결과]**

![image](https://user-images.githubusercontent.com/93081720/158604908-f37647e3-00a9-4391-b09e-4226ac5b4dec.png)

```python
postorder(1) # 8 9 4 10 5 2 6 7 3 1
```



#### ※ 이진 트리의 저장

일반적으로 트리를 저장할 때 각 정점마다 자식 정보를 저장함(필요할 경우 부모 정보도 저장)

##### 방법 1

높이가 h인 이진 트리의 최대 노드 수는 2^(h+1) -1개 이므로 크기가 2^(h+1)개인 빈 배열을 선언한다.
완전 이진 트리 특성 상 이전 계층까지의 노드는 모두 채워져 있으므로 도중에 0이 나오지는 않는다. 따라서 노드가 끊기는 순간 0이 나오는 것이므로, 깊이 우선 탐색의 종료 조건을 `if tree[v] == 0 : return`과 같이 해줘도 된다.

- 단점: 사용하지 않는 배열 원소에 대한 메모리 공간 낭비 발생, 트리 중간에 새로운 노드의 삽입, 기존 노드의 삭제 등이 발생할 경우 배열의 크기 변경이 어려워 비효율적임



##### 방법 2

이진 트리는 왼쪽 자식 노드, 오른쪽 자식 노드 이렇게 2개의 자식 노드만 존재하므로 2개의 자식 배열을 선언하고, 부모 번호를 인덱스로 하여 자식 번호를 저장한다.

| **부모**        | **P** | **0** | 1    | 2    | 3    | 4    | 5    | 6    | 7    |
| --------------- | ----- | ----- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| **왼쪽 자식**   | **L** |       | 2    | 4    | 6    | 8    | 10   | 12   | 14   |
| **오른쪽 자식** | **R** |       | 3    | 5    | 7    | 9    | 11   | 13   | 15   |

 이때, parent 배열은 [0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7]이다.

```python
# 이진 트리 입력받아 저장하기 예시
T = int(input())
for t in range(1, T+1):
    E, N = map(int, input().split()) # E는 간선의 개수
    lst = list(map(int, input().split())) # lst의 짝수번째 인덱스는 부모, 홀수는 자식
    L = [0] * (E+2)
    R = [0] * (E+2)
    for i in range(E):
        p = lst[i*2]
        c = lst[i*2+1]
        if L[p]:
            R[p] = c
        else:
            L[p] = c
```







※ 조상 찾기

```python
# 5번 노드의 조상 찾기
anc = [] # 조상을 담을 배열
c = 5
while (parent[c] != 0):
    c = parent[c] # 조상을 거슬러 올라감
    anc.append(c)

print(anc) # [2, 1]
root = c # while문 마지막에 빠져나온 c가 루트임
```

