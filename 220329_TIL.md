# 220329_TIL

### 01. 다이나믹 프로그래밍(DP)

다이나믹 프로그래밍은 백트랙킹(dfs)와 유사함

메모이제이션과 다이나믹 프로그래밍의 차이는 사실 엄청 크지 않다.

메모이제이션 - 재귀함수로 구현, 탑 다운(값의 호출을 위에서 아래으로 내려가는 구조)

다이나믹 프로그래밍 - 반복문으로 구현, 바텀 업(값을 아래에서부터 위로 올라가는 구조)



#### 메모이제이션(memoization) - 탑 다운

메모이제이션 적용하려면 점화식을 재귀호출로, 반환값을 처리하는 형태로 구현해야한다. 

문제 크기 만큼 기록할 메모 공간(배열)을 생성한다.

- 문제에서 절대 나올 수 없는 값을 초기값으로 선택하여 배열을 초기화한다.

함수 호출 내부에서 매개변수(n)에 해당하는 문제를 이미 풀었는지 확인한다.

- memo[n]에 초기값인지 아닌지 확인 => `if memo[n] == val: ~~` 
- 이미 풀었다면 memo[n] 을 리턴하고 종료
- 그렇지 않으면, 계속 진행해서 결과를 계산해서 memo[n]에 저장하고 memo[n]을 리턴

```python
# 메모이제이션 적용하기
# n번 피보나치 수를 구하기 위해서 풀어야할 문제들 = 0 ~ N 까지
def fibo(n):
    if memo[n] != -1:
        return memo[n]

    memo[n] = fibo(n - 1) + fibo(n - 2)
    return memo[n]

N = 7
memo = [-1] * (N + 1) # 피보나치 수열에서 -1이라는 값은 절대 나올 수 없는 값임
memo[0], memo[1] = 0, 1
print(fibo(N))
```



#### 반복문 기반 다이나믹 프로그래밍 - 바텀 업

 ```python
 dp = [0] * (N + 1)
 dp[0], dp[1] = 0, 1
 
 for i in range(2, n + 1):
     dp[i] = dp[i - 1] + dp[i - 2]
 
 print(dp[N])
 ```



